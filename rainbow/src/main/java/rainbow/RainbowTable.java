package rainbow;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Class for loading and using pre-generated rainbow tables. The format of the
 * table is the one generated by RainbowGen, but must be sorted by the first
 * column before being used by this class. This is done so we can reduce memory
 * usage and use binary search.
 */
public class RainbowTable {
    public final int tableIdx;
    public final int chainLength;
    public final HashProblem problem;
    public final Map<ByteArray, byte[]> chains;

    /**
     * @param chains
     *            The chains in the table.
     * @param problem
     *            The problem to be solved by the table.
     * @param tableIdx
     *            A number to differentiate multiple tables for the same problem.
     * @param chainLength
     *            The length of the chains to use.
     */
    public RainbowTable(Map<ByteArray, byte[]> chains, HashProblem problem, int tableIdx, int chainLength) {
        this.tableIdx = tableIdx;
        this.chainLength = chainLength;
        this.problem = problem;
        this.chains = chains;
    }

    /**
     * @param file
     *            The file to load chains from
     * @param problem
     *            The problem of the table.
     * @param tableIdx
     *            The index of the table.
     * @param chainLength
     *            The length of the chains.
     * @return The new rainbow table.
     * @throws IOException
     */
    public static RainbowTable loadFile(Path file, HashProblem problem, int tableIdx, int chainLength)
            throws IOException {
        if (Files.exists(file)) {
            var decoder = Base64.getUrlDecoder();
            var chains = Files.lines(file)
                    .map(line -> line.split(" "))
                    .collect(Collectors.toMap(line -> new ByteArray(decoder.decode(line[0])),
                            line -> decoder.decode(line.length > 1 ? line[1] : "")));
            return new RainbowTable(chains, problem, tableIdx, chainLength);
        } else {
            return new RainbowTable(new HashMap<>(), problem, tableIdx, chainLength);
        }
    }

    /**
     * @param file
     *            The save to save to.
     * @throws IOException
     */
    public void saveFile(Path file) throws IOException {
        try (var output = Files.newBufferedWriter(file, StandardOpenOption.CREATE,
                StandardOpenOption.TRUNCATE_EXISTING)) {
            var encoder = Base64.getUrlEncoder();
            for (var entry : chains.entrySet()) {
                output.write(encoder.encodeToString(entry.getKey().bytes));
                output.write(" ");
                output.write(encoder.encodeToString(entry.getValue()));
                output.write("\n");
            }
        }
    }

    /**
     * @param password
     *            The password to hash.
     * @return The hash for this tables problem.
     */
    public byte[] hash(byte[] password) {
        return problem.hash(password);
    }

    /**
     * @param hash
     *            The hash to reduce.
     * @param iter
     *            The iteration.
     * @return The reduction at iteration {@code iter} of this table.
     */
    public byte[] reduce(byte[] hash, int iter) {
        return problem.reduce(hash, iter + tableIdx * chainLength);
    }

    /**
     * @param start
     *            The start of the chain.
     * @param length
     *            The length of the chain.
     * @return The end of the chain.
     */
    public byte[] buildChain(byte[] start, int length) {
        var current = start;
        for (int i = length; i > 0; i--) {
            current = reduce(hash(current), i);
        }
        return current;
    }

    /**
     * @param start
     *            The start of the chain.
     * @param hash
     *            The hash to search for.
     * @return The password if found or null otherwise.
     */
    public byte[] searchInChain(byte[] start, byte[] hash) {
        var current = start;
        for (int i = chainLength; i > 0; i--) {
            var h = hash(current);
            if (Arrays.equals(h, hash)) {
                return current;
            }
            current = reduce(h, i);
        }
        return null;
    }

    /**
     * @param hash
     *            The hash too look for.
     * @param offset
     *            The offset in the chain at which to look.
     * @return The password if found or null otherwise.
     */
    public byte[] lookup(byte[] hash, int offset) {
        var middle = reduce(hash, offset + 1);
        var end = buildChain(middle, offset);
        var start = chains.get(new ByteArray(end));
        if (start != null) {
            return searchInChain(start, hash);
        }
        return null;
    }

    /**
     * @param hash
     *            The hash to look for.
     * @return The password if found or null otherwise.
     */
    public byte[] lookup(byte[] hash) {
        for (int i = 0; i < chainLength; i++) {
            var res = lookup(hash, i);
            if (res != null) {
                return res;
            }
        }
        return null;
    }
}
